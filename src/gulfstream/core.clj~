(ns galasox.soxcore
  (:import (java.net InetAddress InetSocketAddress ServerSocket Socket SocketException)
           (java.io InputStreamReader OutputStream
                    OutputStreamWriter BufferedReader)) ;;todo-- clean this up!
  (:use [clojure.core.async :only [go thread close! <! >! alts!! put! take! timeout chan sliding-buffer dropping-buffer]])
  (:require [clojure.data.codec.base64 :as base64]))

(def ds (chan (sliding-buffer 100))) ;;debug stream, ignore me


(defn peek! [ch & args]
  "quickly looks at a channel for new incoming data, pulls it if it exists, quits otherwise;
returns seq if specifying max elements to pull"
  (if-not (nil? args)
    (let [s (remove nil? (repeatedly (first args) #(peek! ch)))] (if-not (empty? s) s nil))
    (let [[m ch] (alts!! [ch (timeout 0)])] m)))


(defn close-socket [^Socket s]
  (if-not (.isClosed s)
    (doto s
      (.shutdownInput)
      (.shutdownOutput)
      (.close))))

(defn send! [bouts data]
  "writes to buffered output stream and flushes"
     (doto bouts
       (.write data 0 (dec(count data)))
       (.flush)))



;;websocket stuff- todo: move to another file
(defn- get-ws-key [req]
  (first(clojure.string/split(second(clojure.string/split req #"Sec-WebSocket-Key: ")) #"\r\n")))

(defn- make-ws-hash [key]
  (let [s (str key "258EAFA5-E914-47DA-95CA-C5AB0DC85B11")]
    (String.(base64/encode(.digest (java.security.MessageDigest/getInstance "sha1") (.getBytes s))) "UTF8")))

(defn- ws-handshake [req]
  (let [key (make-ws-hash (get-ws-key req))]
    (.getBytes(str "HTTP/1.1 101 Switching Protocols\r\n"
       "Upgrade: websocket\r\n"
       "Connection: Upgrade\r\n"
       "Sec-WebSocket-Accept: " key "\r\n"
       ;"Sec-WebSocket-Protocol: chat\r\n" ;;todo: provide subprotocol support for non-ws sockets as well
       "\r\n\r\n") "UTF8")))

(defn- req-ws! [req bouts]
  (if (.startsWith req "GET") ;;websocket upgrade?
    (do(send! bouts (ws-handshake req))
       true)
    false))

(defn- ws-decode [data]
 ;; todo: make this do something
  )
;;end websocket stuff


(defn get-chunk [client buf]
  "returns map of bytes and size of buffer for data recieved in stream"
  (if (> (.available (:ins client)) 0);;todo: consider just blocking instead
    (let [bufsize (.read (:bins client) buf)] ;;blocking
      {:size bufsize :data buf})))

(defn str-chunk [chunk]
  "returns a utf8 string of the data received in stream"
  (String. (:data chunk) 0 (:size chunk) "UTF8"))


(defn listen! [client fun]
  "listens to clients instream socket"
  (put! ds {"listening!" client})
  (let [buf (make-array Byte/TYPE 4096)
        data (get-chunk client buf)
        ws (req-ws! (str-chunk data) bouts)]
    (if-not ws 
      (go(fun data));;not websocket? deal with first chunk
      (put! ds {"websocket upgraded!" (str-chunk data)}))

    (loop [ws? ws]
      (if-let [data (get-chunk (:ins client) (:bins client) buf)]
        (go(fun data)))
      (if (:serversocket client)
        (if (.isClosed (:serversocket client))
          (close-socket (:socket client)))) ;;close client, logical stop to this loop as well
      (if-not (.isClosed (:socket client))
          (recur ws?))))
    (put! ds {"stopped listening!" client}))


(defmacro with-data [c v & body] 
  "preps with-data function similar to with-client, wraps it with the listen! function; the data is then applied to the functions specified within"
  `(listen! ~c (fn with-data#[d#] (let [~v d#] ~@body ))))

(defmacro with-client [v & body]
  "client var is filled with client-map once passed through the handle-client function; client can be used for functions as a handler"
  `(fn with-client#[c#] (let [~v c#] ~@body)))


(defn- build-client [^Socket socket]
  "builds inital client map to be merged with"
  (let [ins (.getInputStream cs)
        bins (java.io.BufferedInputStream. ins)
        outs (.getOutputStream cs)
        bouts (java.io.BufferedOutputStream. outs)]
    {:ins ins :bins bins :outs outs :bouts bouts :socket socket}))


(defn- handle-client [client]
  "typical logic for client: connect, receive loop, close"
  (put! ds {"handling" client})
  (try ((:handler client) client)
       (catch Exception e (put! ds (.getMessage e))))
  (put! ds {"closing" client})
  (close-socket (:socket client)))


(defn- await-clients [server]
  "spins off 1 thread to accept new clients on, spins off go blocks for client handling, merges client-map with server-map to supply serversocket and handler info"
  (let [server (conj server {:host (.getInetAddress (:serversocket server))})
        server (conj server 
                     {:thread (thread (loop [] 
                         (if-let [socket (.accept (:serversocket server))]
                           (do (put! ds "accepted client")
                           (try (let [client (conj (build-client socket) server)]
                                  (thread(handle-client client)))
                                (catch Exception e (put! ds (.getMessage e))))))
                         (if-not (.isClosed (:serversocket server)) (recur))))
                      })]
    server))


(defn start-server [server]
  (if-let [socket (ServerSocket. (:port server) 0 (InetAddress/getByName (:host server)))]
    (await-clients (conj server {:serversocket socket}))))
(defn stop-server [server]
  (.close (:serversocket server))
  (close! (:thread server)))


(defn start-client [server]
  (let [client (build-client (Socket. (:host server) (:port server)))
        client (conj client {:thread (thread(handle-client (conj client server)))})]
    client))
(defn stop-client [client]
  (close-socket (:socket client))
  (close! (:thread client)))
