(ns galasox.soxcore
  (:import (java.net InetAddress InetSocketAddress ServerSocket Socket SocketException)
           (java.io InputStreamReader OutputStream
                    OutputStreamWriter PrintWriter BufferedReader)
           (clojure.lang LineNumberingPushbackReader))
  (:require [clojure.java.io :as io]
            [swiss.arrows :refer :all])
  (:use [clojure.core.async :only [<!! <! >!! >! alts!! alts! timeout go thread chan close! sliding-buffer]]))

(defn peek! [ch & args]
  "quickly looks at a channel for new incoming data, pulls it if it exists, quits otherwise;
returns seq if specifying max elements to pull"
  (if-not (nil? args)
    (let [s (remove nil? (repeatedly (first args) #(peek! ch)))] (if-not (empty? s) s nil))
    (let [[m ch] (alts!! [ch (timeout 1)])] m)))


(defn close-socket [^Socket s]
  (if-not (.isClosed s)
    (doto s
      (.shutdownInput)
      (.shutdownOutput)
      (.close))))

(defn send! [client data]
  "prints and flushes basic data to client socket"
     (doto (:out client)
       (.println data)
       (.flush)))

(def ds (chan (sliding-buffer 10))) ;;debug stream, ignore me

(defn do-data [client fun]
  "applies incoming data to supplied functions"
  (if (> (.available (:ins client)) 0)
      (let [line (.readLine (:in client))]
        (fun line)
        (if (:serversocket client) (go(>! ds line))))))

(defn listen! [client fun]
  "listens to clients instream socket"
  (go(>! ds {"listening!" client}))
    (loop []
      (do-data client fun)
      (if (:serversocket client)
        (if (.isClosed (:serversocket client))
          (close-socket (:socket client)))) ;;close client, logical stop to this loop as well
      (if-not (.isClosed (:socket client))
          (recur)))
    (go(>! ds {"stopped listening!" client})))


(defmacro with-data [c v & body] 
  "preps with-data function similar to with-client, wraps it with the listen! function; the data is then applied to the functions specified within"
  `(listen! ~c (fn with-data#[d#] (let [~v d#] ~@body ))))

(defmacro with-client [v & body]
  "client var is filled with client-map once passed through the handle-client function; client can be used for functions as a handler"
  `(fn with-client#[c#] (let [~v c#] ~@body)))


(defn- build-client [^Socket socket]
  "builds inital client map to be merged with"
  (let [ins (.getInputStream socket)
        in (BufferedReader. (InputStreamReader. ins))
        out (PrintWriter. (.getOutputStream socket))]
    {:ins ins :in in :out out :socket socket}))


(defn- handle-client [client]
  "logical client flow: connect, receive/handle loop, close"
  (go(>! ds {"handling" client}))
  (try ((:handler client) client)
       (go(>! ds {"handled" client}))
       (catch Exception e (go(>! ds (.getMessage e)))))
  (go(>! ds {"closing" client}))
  (close-socket (:socket client)))


(defn- await-clients [server]
  "spins off 1 thread to accept new clients on, spins off go blocks for client handling, merges client-map with server-map to supply serversocket and handler info"
  (let [server (conj server {:host (.getInetAddress (:serversocket server))})
        server (conj server 
                     {:thread (thread (loop [] 
                         (if-let [socket (.accept (:serversocket server))]
                           (do (go(>! ds "accepted client"))
                           (try (let [client (conj (build-client socket) server)]
                           (go(handle-client client)))
                                (catch Exception e (go(>! ds (.getMessage e)))))))
                         (if-not (.isClosed (:serversocket server)) (recur))))
                      })]
    server))


(defn start-server [server]
  (if-let [socket (ServerSocket. (:port server) 0 (InetAddress/getByName (:host server)))]
    (await-clients (conj server {:serversocket socket}))))
(defn stop-server [server]
  (.close (:serversocket server))
  (close! (:thread server)))


(defn start-client [server]
  (let [client (build-client (Socket. (:host server) (:port server)))
        client (conj client {:thread (thread(handle-client (conj client server)))})]
    client))
(defn stop-client [client]
  (close-socket (:socket client))
  (close! (:thread client)))
